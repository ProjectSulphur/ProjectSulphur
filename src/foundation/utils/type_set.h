#pragma once

#include <type_traits>

namespace sulphur
{
  namespace foundation
  {
    namespace detail
    {
      /**
      * @struct sulphur::foundation::TypeSetHelper <T>
      * @brief A structure only used for storing the unique ID's generated by sulphur::engine::TypeSet
      * @author Maarten ten Velden
      */
      template<typename T>
      struct TypeSetHelper
      {
        static size_t next_id; //!< The unique ID
      };

      template<typename T>
      size_t TypeSetHelper<T>::next_id = 0;
    }
    
    //-------------------------------------------------------------------------
    /**
    * @class sulphur::foundation::TypeInfo <Base, Key>
    * @brief A class that assigns unique identifiers to each child-type of a shared base
    * @author Maarten ten Velden
    */
    template<typename Base, typename Key>
    class TypeSet : public Base
    {
    public:
      /**
      * @brief default constructor which sets up static ID on first run
      * @tparam Args (typename...) Vararg constructor argument types
      * @param[in] args (Args&&) The arguments to pass trough the base class constructor
      */
      template<typename... Args>
      TypeSet(Args&& ...args);

      /**
      * @brief Returns the unique ID of the specified type.
      * @return (size_t) The unique ID
      * @remarks The returned ID will be undefined if the constructor of this class has not been called once.
      */
      static size_t type_id();

    protected:
      static size_t type_id_; //!< Unique ID that identifies the type
    };

    //-------------------------------------------------------------------------
    template<typename Base, typename T>
    template<typename... Args>
    TypeSet<Base, T>::TypeSet(Args&&... args) :
      Base(std::forward<Args>(args)...)
    {
      static bool is_setup = false;
      if (!is_setup)
      {
        type_id_ = detail::TypeSetHelper<Base>::next_id;
        ++detail::TypeSetHelper<Base>::next_id;
        is_setup = true;
      }
    }

    //-------------------------------------------------------------------------
    template<typename Base, typename T>
    size_t TypeSet<Base, T>::type_id()
    {
      return type_id_;
    }

    //-------------------------------------------------------------------------
    template<typename Base, typename T>
    size_t TypeSet<Base, T>::type_id_ = 0;

  }
}
